\chapter{Ticket Management System}

\section{Introduzione}

La soluzione \textit{TicketManagement} è stata concepita come piattaforma modulare e scalabile per la gestione strutturata di ticket, ossia unità di lavoro che rappresentano richieste, incidenti o attività da tracciare all'interno di un'organizzazione. L'adozione di sistemi di questo tipo risponde a un'esigenza ormai diffusa in contesti eterogenei, che spaziano dal supporto tecnico informatico alla gestione di eventi fino al coordinamento di flussi operativi complessi. In tali scenari, l'obiettivo primario non è soltanto quello di centralizzare la registrazione delle richieste, ma anche di garantire un processo di lavorazione tracciabile, collaborativo ed efficiente, capace di ridurre i tempi di risoluzione e di migliorare la produttività complessiva dei team coinvolti.
\\
Il sistema affronta in particolare una serie di problematiche tipiche nella gestione delle attività organizzative. Tra queste, si annoverano la necessità di centralizzare le richieste, evitando dispersioni di informazioni; la possibilità di monitorare lo stato e la cronologia di ciascun ticket, garantendo trasparenza e accountability; la gestione flessibile dell'assegnazione dei task, sia essa automatica o manuale; l'erogazione di notifiche in tempo reale agli utenti coinvolti, al fine di favorire la comunicazione tempestiva; e, infine, la produzione di analisi e reportistica utili a valutare l'efficienza dei processi.
\\
Per rispondere a tali esigenze, la \textit{solution} offre un insieme articolato di funzionalità. Tra le principali si annoverano la creazione, la modifica e la chiusura dei ticket, la gestione degli utenti e dei relativi ruoli, l'implementazione di workflow di assegnazione ed escalation, nonché la possibilità di integrazione con sistemi esterni mediante API. Ulteriori caratteristiche qualificanti comprendono una dashboard interattiva con strumenti di reportistica e il supporto nativo al pattern \textit{CQRS} (Command Query Responsibility Segregation), che favorisce una maggiore scalabilità e manutenibilità del sistema.
\\
Dal punto di vista tecnologico, \textit{TicketManagement} si fonda su un'infrastruttura moderna e consolidata. Il progetto utilizza \textit{.NET 8/9} come framework principale per lo sviluppo backend e frontend, sfruttandone le capacità in termini di prestazioni, sicurezza e aderenza alle architetture contemporanee. La persistenza dei dati è gestita attraverso \textit{Entity Framework Core}, che semplifica l'interazione con database relazionali mediante l'uso di un ORM (Object-Relational Mapping). La creazione di API RESTful e interfacce web è supportata da \textit{ASP.NET Core}, mentre l'adozione di un framework \textit{CQRS} dedicato consente di separare le operazioni di lettura e scrittura, incrementando la scalabilità e migliorando la manutenzione del codice. Completano l'ecosistema ulteriori librerie dedicate al logging, all'autenticazione e alla gestione delle notifiche, che contribuiscono a rendere la soluzione robusta, sicura e facilmente estendibile.
\\
In sintesi, \textit{TicketManagement} si configura come un sistema complesso ma al tempo stesso flessibile, capace di affrontare in maniera organica le principali sfide legate alla gestione dei ticket. La combinazione tra un'architettura modulare, un set di funzionalità avanzate e l'impiego di tecnologie all'avanguardia rende la \textit{solution} idonea a diversi contesti applicativi e ne sottolinea il potenziale come strumento di supporto alla produttività e all'efficienza aziendale.

\subsection{Struttura architetturale della solution}
La \textit{solution TicketManagement} è stata progettata secondo un approccio modulare, in cui le diverse responsabilità funzionali vengono distribuite tra più progetti indipendenti ma interconnessi. Tale organizzazione riflette i principi delle moderne architetture software a livelli, favorendo la separazione delle preoccupazioni (\textit{Separation of Concerns}), la manutenibilità e la possibilità di estendere il sistema senza introdurre dipendenze circolari o accoppiamenti eccessivamente rigidi.
\\
La composizione della solution prevede cinque progetti principali, ciascuno con un ruolo ben definito. Il progetto \textit{TM.Shared}, realizzato come libreria di classi, rappresenta la base comune dell'intero ecosistema e contiene modelli, costanti e logica condivisa, utilizzati trasversalmente dagli altri moduli. \textit{TM.Data}, anch'esso strutturato come libreria di classi, ha il compito di gestire la persistenza delle informazioni, fornendo l'accesso al database e interagendo strettamente con i modelli definiti in \textit{TM.Shared}. Il progetto \textit{TM.CQRS} introduce l'implementazione del pattern \textit{Command Query Responsibility Segregation}, offrendo un ulteriore livello di astrazione e separazione tra operazioni di lettura e scrittura dei dati; esso dipende da \textit{TM.Shared} e coopera sia con \textit{TM.Data} sia con \textit{TM.Function}.
\\
Il cuore della logica applicativa è rappresentato da \textit{TM.Function}, presumibilmente implementato come \textit{Web API}. Esso svolge il ruolo di orchestratore, coordinando le operazioni tra i moduli di persistenza e quelli che applicano i pattern architetturali, ed esponendo al contempo servizi RESTful utilizzati dai client esterni. Infine, \textit{TM.Client} costituisce l'interfaccia utente, che può essere realizzata come applicazione desktop o come front-end web. Questo progetto comunica con \textit{TM.Function} tramite API e, come gli altri moduli, dipende da \textit{TM.Shared} per il riuso di modelli e definizioni comuni.
\\
Da questa rappresentazione emerge chiaramente la natura stratificata della solution: \textit{TM.Shared} costituisce il nucleo comune, \textit{TM.Data} e \textit{TM.CQRS} estendono e specializzano la logica, \textit{TM.Function} funge da coordinatore e punto di accesso esterno, mentre \textit{TM.Client} fornisce la parte di interazione diretta con l'utente. Tale disposizione rispetta un modello a livelli, assimilabile a una combinazione tra architettura \textit{layered} e \textit{service-oriented}, con una distinzione netta tra presentazione, business logic e accesso ai dati.
\\
Questa scelta architetturale consente non solo di migliorare la chiarezza e la modularità del codice, ma anche di garantire una maggiore scalabilità, permettendo l'eventuale sostituzione o estensione di singoli moduli senza compromettere la stabilità dell'intera soluzione.
\section{Descrizione dei progetti}
\subsection{TM.Client}

Il progetto \textit{TM.Client} costituisce il front-end della soluzione \textit{TicketManagement} ed è dedicato alla gestione dell'interfaccia utente e delle interazioni con il backend. La sua funzione primaria è consentire agli utenti finali di creare, visualizzare, modificare ed eliminare entità del sistema (ticket, task, commenti, categorie e utenti), fungendo da punto di accesso principale alla piattaforma. In questo contesto, \textit{TM.Client} svolge un ruolo di mediazione tra la presentazione grafica e la logica di business implementata nel progetto \textit{TM.Function}.
\\
\subsubsection{Namespace principali}

Il progetto è strutturato in namespace distinti che favoriscono la separazione delle responsabilità:
\begin{itemize}
\item \textit{TM.Client}: contiene la logica complessiva dell'interfaccia utente e i servizi di comunicazione con il backend.

\item \textit{TM.Client.Services}: gestisce le chiamate verso le API esposte da \textit{TM.Function}, occupandosi dell'integrazione dei dati e delle operazioni CRUD.

\item \textit{TM.Client.ViewModels}: implementa la logica di presentazione secondo il pattern \textit{MVVM} (Model-View-ViewModel), garantendo il binding tra i dati e i componenti grafici.

\item \textit{TM.Client.Views}: definisce le pagine, finestre o componenti visuali che costituiscono l'esperienza utente.
\end{itemize}

\subsubsection{Classi rilevanti}

Tra le classi più significative si distinguono:
\begin{itemize}
\item \textit{MainWindow} / \textit{App}: rappresentano il punto di ingresso dell'applicazione, inizializzando il ciclo di vita del client.

\item \textit{TicketViewModel}, \textit{UserViewModel}, \textit{TaskViewModel}, \textit{CategoryViewModel}, \textit{CommentViewModel}: ciascuna di queste classi incapsula lo stato e le operazioni relative a specifiche entità del dominio, offrendo un'interfaccia coerente alla UI.

\item \textit{ApiService}, \textit{TicketService}, \textit{UserService}: gestiscono la comunicazione con il backend, incapsulando la logica di invio e ricezione delle richieste HTTP verso \textit{TM.Function}.

\item \textit{DTOs} (Data Transfer Objects): modelli utilizzati per il trasferimento dei dati tra client e backend, spesso derivati da \textit{TM.Shared} per garantire uniformità e coerenza semantica.
\end{itemize}

\subsubsection{Dipendenze}

\textit{TM.Client} dipende direttamente da \textit{TM.Shared}, da cui eredita modelli e costanti, e da \textit{TM.Function}, con cui comunica tramite API RESTful. A livello tecnico, utilizza librerie per la costruzione dell'interfaccia (ad esempio \textit{WPF}, \textit{Blazor} o equivalenti) e strumenti di supporto come \textit{Newtonsoft.Json} o \textit{System.Text.Json} per la serializzazione e deserializzazione dei dati.

\subsubsection{Ruolo nella solution}

In sintesi, \textit{TM.Client} rappresenta l'anello di congiunzione tra l'utente finale e la logica di business. Grazie all'organizzazione in \textit{Views}, \textit{ViewModels} e \textit{Services}, garantisce una netta separazione delle responsabilità e contribuisce a un'architettura modulare e manutenibile. La sua progettazione orientata all'utente lo rende il componente fondamentale per l'accesso e l'interazione con le funzionalità offerte dalla piattaforma \textit{TicketManagement}.

\subsection{TM.CQRS}

Il progetto \textit{TM.CQRS} rappresenta il nucleo della logica di orchestrazione della soluzione \textit{TicketManagement}, implementando il pattern \textit{CQRS} (Command Query Responsibility Segregation). Tale approccio consente di separare in maniera chiara le operazioni di scrittura, gestite dai comandi (\textit{commands}), da quelle di lettura, gestite dalle query, garantendo una maggiore scalabilità, manutenibilità e testabilità del sistema. \textit{TM.CQRS} si configura quindi come un modulo fondamentale per la gestione delle operazioni di business, fornendo strutture astratte e riutilizzabili per l'implementazione di handler specifici e coerenti con l'architettura complessiva della solution.

\subsubsection{Namespace principali}

Il progetto è organizzato in namespace distinti, ciascuno con una responsabilità precisa:
\begin{itemize}
\item \textit{TM.CQRS.\_Base.Commands}: definisce le classi astratte di base per i comandi, quali \textit{CommandBase} e \textit{CommandBase<T>}, e le interfacce \textit{ICommand} e \textit{ICommand<T>}. Queste classi forniscono identificatori univoci e contratti comuni per la gestione delle operazioni di scrittura.
\item \textit{TM.CQRS.\_Base.Queries}: include le classi base per le query, come \textit{QueryBase<T>}, e l'interfaccia \textit{IQuery<T>}, garantendo uniformità e coerenza nelle operazioni di lettura dei dati.
\item \textit{TM.CQRS.\_Base.Handlers}: contiene le classi astratte per gli handler di comandi e query, tra cui \textit{CommandHandlerBase<TCommand, TResponse>} e \textit{QueryHandlerBase<TQuery, TResponse>}. Tali classi astratte implementano l'interfaccia \textit{IRequestHandler} di \textit{MediatR}, standardizzando la logica di gestione delle richieste.
\item Namespace specifici di dominio: eventuali altri namespace possono essere dedicati all'implementazione concreta dei comandi, query e handler specifici per ciascun ambito funzionale della solution.
\end{itemize}

\subsubsection{Classi rilevanti}

Le principali classi che caratterizzano \textit{TM.CQRS} includono:
\begin{itemize}
\item \textit{CommandBase} / \textit{CommandBase<T>}: classi astratte che rappresentano i comandi, fornendo identificatori univoci e struttura di base per l'estensione.
\item \textit{QueryBase<T>}: classe astratta per le query, analogamente ai comandi, garantendo identificatori univoci e contratti comuni.
\item \textit{CommandHandlerBase<TCommand, TResponse>} e \textit{QueryHandlerBase<TQuery, TResponse>}: classi base per la gestione delle richieste di scrittura e lettura, integrando \textit{MediatR} per orchestrare l'invocazione degli handler.
\item \textit{ICommand}, \textit{ICommand<T>}, \textit{IQuery<T>}: interfacce che tipizzano le operazioni, assicurando una gestione coerente dei comandi e delle query all'interno del sistema.
\end{itemize}

\subsubsection{Dipendenze}

\textit{TM.CQRS} si integra con diverse dipendenze esterne e interne alla solution:
\begin{itemize}
\item \textit{MediatR}: libreria che supporta il pattern \textit{Mediator}, utilizzata per la gestione asincrona e orchestrata dei comandi e delle query.
\item \textit{TM.Shared}: fornisce modelli e DTO condivisi, fondamentali per garantire coerenza e riusabilità tra i vari progetti della solution.
\item Eventuali riferimenti a \textit{TM.Data} o \textit{TM.Function}, che consentono agli handler di interagire con la persistenza dei dati e con la logica applicativa.
\end{itemize}

\subsubsection{Ruolo nella solution}

\textit{TM.CQRS} ha un ruolo centrale all'interno della solution \textit{TicketManagement}, in quanto definisce la struttura per l'implementazione dei comandi e delle query, favorendo la separazione netta delle responsabilità. Grazie a questo modulo, \textit{TM.Function} può orchestrare le operazioni di business in modo chiaro e modulare, mentre altri progetti possono fare affidamento su una gestione consistente delle richieste, senza introdurre accoppiamenti indesiderati. La sua architettura consente inoltre di implementare handler specifici per ogni tipo di operazione, migliorando la scalabilità del codice e la qualità complessiva della soluzione.

\subsubsection{Sintesi architetturale}

\textit{TM.CQRS} si configura come il cuore della logica di orchestrazione della solution:
\begin{itemize}
\item abilita una gestione chiara e separata di comandi e query,
\item si integra con \textit{MediatR} e con i modelli condivisi di \textit{TM.Shared},
\item permette l'implementazione di handler specifici per ciascuna operazione, migliorando manutenibilità, testabilità e qualità complessiva del codice.
\end{itemize}

\subsection{TM.Data}

Il progetto \textit{TM.Data} rappresenta il layer di accesso ai dati della soluzione \textit{TicketManagement} ed è responsabile della gestione della persistenza delle entità del dominio, nonché dell'interazione con il database attraverso \textit{Entity Framework Core} (EF Core). \textit{TM.Data} fornisce contesti dedicati alle operazioni di lettura e scrittura, repository generici e classi di supporto per migrazioni e snapshot del modello dati, consentendo una gestione efficiente, coerente e scalabile dei dati. Il progetto costituisce quindi un elemento chiave della soluzione, fungendo da base per l'implementazione della logica di business e per l'integrazione con il pattern \textit{CQRS} implementato in \textit{TM.CQRS}.

\subsubsection{Namespace principali}

La struttura di \textit{TM.Data} è organizzata in namespace distinti, che separano chiaramente le responsabilità:
\begin{itemize}
\item \textit{TM.Data.Contexts}: include i contesti EF Core utilizzati per gestire la persistenza delle entità. In particolare, \textit{WriteDbContext} è dedicato alle operazioni di scrittura e gestisce le relazioni tra le entità principali del sistema (\textit{User}, \textit{Ticket}, \textit{Task}, \textit{Category}, \textit{Comment}), mentre \textit{ReadDbContext} è ottimizzato per le operazioni di lettura, con configurazioni che disabilitano il tracking e il lazy loading per migliorare le performance.
\item \textit{TM.Data.\_Base}: definisce interfacce generiche e classi base per i repository, come \textit{IRepositoryWrite<T>}, fornendo un contratto standard per le operazioni CRUD e garantendo coerenza e riusabilità del codice di accesso ai dati.
\item \textit{TM.Data.Migrations}: gestisce le migrazioni EF Core e la snapshot del modello, permettendo di mantenere allineato lo schema del database con l'evoluzione del modello di dominio.
\end{itemize}

\subsubsection{Classi rilevanti}

Le principali classi che caratterizzano \textit{TM.Data} includono:
\begin{itemize}
\item \textit{WriteDbContext}: contesto EF Core per operazioni di scrittura, gestisce le entità principali del dominio e le relazioni tra di esse. Supporta transazioni e configurazioni per garantire integrità dei dati durante le modifiche.
\item \textit{ReadDbContext}: contesto ottimizzato per le operazioni di lettura, progettato per massimizzare le prestazioni mediante il disabilitamento del tracking e l'uso di query read-only.
\item \textit{IRepositoryWrite<T>}: interfaccia generica per le operazioni CRUD su entità, che fornisce una base astratta e standardizzata per l'implementazione di repository concreti.
\item Migrazioni e \textit{ModelSnapshot}: classi generate automaticamente da EF Core, essenziali per la gestione dello schema del database e per il controllo delle modifiche nel tempo.
\end{itemize}

\subsubsection{Dipendenze}
\textit{TM.Data} integra diverse dipendenze chiave:
\begin{itemize}
\item \textit{Entity Framework Core}: ORM utilizzato per modellare le entità, gestire le relazioni e orchestrare le operazioni di lettura e scrittura sul database.
\item \textit{TM.Shared}: utilizzato per condividere modelli e DTO tra i vari progetti della solution, garantendo coerenza tra layer.
\item \textit{TM.CQRS}: referenziato per l'integrazione con la logica CQRS, permettendo agli handler di leggere e scrivere i dati tramite i contesti e i repository definiti.
\end{itemize}

\subsubsection{Ruolo nella solution}
Il progetto \textit{TM.Data} costituisce la componente centrale per la gestione della persistenza e dell'accesso ai dati. Fornisce strutture e strumenti per separare in maniera efficiente le operazioni di lettura da quelle di scrittura, ottimizzando le performance complessive del sistema. Funziona come base per la logica di business implementata in \textit{TM.Function} e per l'orchestrazione delle operazioni mediante il pattern \textit{CQRS} in \textit{TM.CQRS}. La sua architettura modulare consente di garantire coerenza e integrità dei dati, facilitando al contempo l'estensione e la manutenzione della solution.

\subsubsection{Sintesi architetturale}
\textit{TM.Data} centralizza la gestione della persistenza tramite contesti EF Core e repository generici, esponendo le entità e le relazioni del dominio \textit{TicketManagement}. Grazie a questa organizzazione, ogni operazione che richiede accesso al database può essere realizzata in modo coerente e scalabile. \textit{TM.Data} costituisce quindi un componente imprescindibile per tutte le funzionalità della solution che interagiscono con i dati, assicurando robustezza, manutenibilità e supporto a pattern architetturali avanzati come \textit{CQRS}.

\subsection{TM.Function}

Il progetto \textit{TM.Function} costituisce il backend serverless della soluzione \textit{TicketManagement}, orchestrando la logica di business tramite l'utilizzo di \textit{Azure Functions} e strumenti di messaggistica asincrona. La sua funzione principale è gestire le operazioni CRUD e altre funzionalità relative alle entità del dominio (ticket, task, commenti, categorie e utenti), fungendo da ponte tra il front-end (\textit{TM.Client}) e il layer di persistenza dei dati (\textit{TM.Data}). La progettazione modulare e l'integrazione con il pattern \textit{CQRS} ne garantiscono scalabilità, manutenibilità e possibilità di estensione in ambienti cloud.

\subsubsection{Namespace principali}

\textit{TM.Function} organizza le proprie responsabilità in namespace distinti:
\begin{itemize}
\item \textit{TM.Function}: contiene le \textit{Azure Functions} e i tool \textit{MCP}, fornendo implementazioni concrete per la gestione delle entità del dominio. Questo namespace definisce endpoint serverless pronti per essere consumati dal client o da altri servizi.

\item \textit{TM.Function.\_Base}: include classi base e interfacce generiche, come \textit{FunctionBase}, \textit{CreateEntityFunctionBase} e \textit{IFunction}, che stabiliscono contratti di esecuzione e forniscono strumenti comuni per la gestione delle funzioni. Questo namespace promuove la riusabilità e l'astrazione della logica di business.
\end{itemize}

\subsubsection{Classi rilevanti}

Tra le classi principali si distinguono:
\begin{itemize}
\item \textit{TicketManagementTools}: espone funzioni \textit{MCP} per la gestione delle entità principali (\textit{Ticket}, \textit{Task}, \textit{Comment}, \textit{Category}, \textit{User}), utilizzando store in-memory a scopo dimostrativo.

\item \textit{FunctionBase} / \textit{FunctionBase<T>}: classi base astratte per tutte le funzioni, definiscono identificatori univoci e contratti standard di esecuzione, consentendo uniformità nella gestione delle operazioni.

\item \textit{IFunction} / \textit{IFunction<T>}: interfacce per la definizione di funzioni generiche e tipizzate, che supportano la coerenza tra implementazioni concrete.

\item \textit{CreateEntityFunctionBase<TEntity, TDtoCreate>}: classe base specializzata per la creazione di entità, che gestisce la deserializzazione dei dati, la validazione, l'invio dei comandi tramite \textit{MediatR} e la comunicazione asincrona tramite \textit{Service Bus}.
\end{itemize}

\subsubsection{Dipendenze}

\textit{TM.Function} si integra con numerose librerie e progetti della solution:

\begin{itemize}
\item \textit{TM.Shared}: per modelli, DTO e schemi condivisi tra i vari progetti, garantendo consistenza dei dati.

\item \textit{TM.CQRS}: per la gestione decoupled dei comandi e delle query, implementando il pattern \textit{CQRS}.

\item \textit{Azure Functions Worker}: framework per la definizione e l'hosting delle \textit{Azure Functions}, che consente l'esecuzione serverless.

\item \textit{MediatR}: utilizzato per l'orchestrazione dei comandi e delle query in modo modulare e disaccoppiato.

\item \textit{Azure.Messaging.ServiceBus}: per la comunicazione asincrona tra funzioni e servizi.

\item \textit{Castle.Core.Logging}: per la gestione del logging e del tracciamento delle operazioni.
\end{itemize}

\subsubsection{Ruolo nella solution}

\textit{TM.Function} rappresenta il punto centrale per la logica di business della soluzione \textit{TicketManagement}. Consente l'integrazione tra il front-end e il layer di persistenza, orchestrando le operazioni tramite \textit{Azure Functions}, implementando \textit{CQRS} e garantendo un'architettura modulare e scalabile. Le funzionalità serverless e la possibilità di estendere il sistema con nuovi endpoint e tool \textit{MCP} rendono \textit{TM.Function} un componente fondamentale per la gestione delle operazioni automatizzate della piattaforma.

\subsubsection{Sintesi architetturale}

In sintesi, \textit{TM.Function} centralizza l'orchestrazione delle operazioni e la logica di business, integrandosi con:
\begin{itemize}
\item \textit{TM.Shared}, per modelli e DTO;

\item \textit{TM.CQRS}, per la gestione dei comandi e delle query;

\item \textit{TM.Data}, per la persistenza dei dati.
\end{itemize}

La separazione tra logica di presentazione, persistenza e orchestrazione serverless garantisce modularità, manutenibilità e scalabilità, rendendo \textit{TM.Function} un elemento cruciale della soluzione \textit{TicketManagement}.

\subsection{TM.Shared}

Il progetto \textit{TM.Shared} costituisce il modello di dominio centrale della soluzione \textit{TicketManagement}, fornendo le entità, le enumerazioni e le classi base condivise da tutti gli altri progetti della solution. La sua funzione principale è definire le strutture dati e i contratti comuni utilizzati per garantire coerenza, integrità e riusabilità dei dati tra persistenza, logica di business, API e interfaccia utente. \textit{TM.Shared} non dipende da librerie esterne, essendo una libreria di classi standalone, e rappresenta pertanto la base fondamentale su cui si innestano tutti i layer applicativi.

\subsubsection{Namespace principali}

La struttura di \textit{TM.Shared} è organizzata in namespace distinti:
\begin{itemize}
\item \textit{TM.Shared.Models}: include le entità di dominio principali, quali \textit{User}, \textit{Ticket}, \textit{Task}, \textit{Comment} e \textit{Category}, insieme alle enumerazioni \textit{TicketStatus}, \textit{TicketPriority} e \textit{TaskStatus}. Questo namespace definisce le proprietà, le relazioni e le regole principali del dominio.

\item \textit{TM.Shared.\_Base.Models} (presunto): contiene classi base, come \textit{EntityBase}, da cui derivano le entità principali, promuovendo uniformità e coerenza nella definizione dei modelli.
\end{itemize}

\subsubsection{Classi rilevanti}

Tra le classi più significative di \textit{TM.Shared} si evidenziano:
\begin{itemize}
\item \textit{User}: rappresenta un utente del sistema, definendo proprietà identificative e relazioni con i ticket, i task e i commenti creati o assegnati.

\item \textit{Ticket}: modella una richiesta o un incidente, con dettagli, stato, priorità e relazioni verso utente creatore, categoria, task e commenti associati.

\item \textit{Task}: rappresenta un'attività collegata a un ticket, assegnata a un utente, con proprietà che ne definiscono lo stato e la descrizione.

\item \textit{Comment}: gestisce i commenti associati ai ticket, definendo autore, contenuto e data di creazione.

\item \textit{Category}: definisce la categoria di un ticket, con nome, descrizione e collezione di ticket associati.

\item Enumerazioni: \textit{TicketStatus} (Open, InProgress, Closed), \textit{TicketPriority} (Low, Medium, High) e \textit{TaskStatus} (Pending, InProgress, Completed), fondamentali per modellare lo stato e la priorità delle entità.
\end{itemize}

\subsubsection{Dipendenze}

\textit{TM.Shared} non presenta dipendenze esterne, essendo progettato come libreria autonoma. Viene utilizzato come base comune da \textit{TM.Data}, \textit{TM.Function}, \textit{TM.CQRS} e \textit{TM.Client}, garantendo uniformità nella definizione dei modelli e integrità dei dati tra i vari layer della solution.

\subsubsection{Ruolo nella solution}

\textit{TM.Shared} funge da contratto comune per tutti i progetti della solution \textit{TicketManagement}. Garantisce coerenza semantica e riusabilità dei dati, rappresentando il punto di riferimento per la definizione delle entità e delle loro relazioni. Tutti i layer applicativi, dalla persistenza alla logica di business, dalle API al client, si basano sui modelli definiti in \textit{TM.Shared}, rendendo il progetto imprescindibile per la manutenzione e l'estensione della piattaforma.

\subsubsection{Sintesi architetturale}

In sintesi, \textit{TM.Shared} costituisce la base dati e il contratto di dominio della solution \textit{TicketManagement}:
\begin{itemize}
\item espone entità e enumerazioni fondamentali,

\item non richiede dipendenze esterne,

\item viene referenziato da \textit{TM.Data}, \textit{TM.Function}, \textit{TM.CQRS} e \textit{TM.Client} per garantire coerenza e integrità dei dati in tutto il sistema.
\end{itemize}

\section{Conclusione}

Il capitolo ha illustrato in dettaglio la composizione della solution \textit{TicketManagement}, evidenziando i singoli progetti che ne costituiscono l'architettura modulare e le rispettive responsabilità. La descrizione dei progetti \textit{TM.Shared}, \textit{TM.Data}, \textit{TM.CQRS}, \textit{TM.Function} e \textit{TM.Client} ha messo in luce come ogni componente contribuisca in maniera specifica al funzionamento complessivo del sistema, rispettando i principi di modularità, coesione e separazione delle responsabilità.
\\
In particolare, \textit{TM.Shared} definisce il modello di dominio comune, garantendo coerenza tra tutti i layer; \textit{TM.Data} centralizza la gestione della persistenza e delle operazioni sul database; \textit{TM.CQRS} implementa il pattern \textit{Command Query Responsibility Segregation}, separando logicamente le operazioni di lettura da quelle di scrittura; \textit{TM.Function} orchestrando la logica di business tramite \textit{Azure Functions}, funge da ponte tra il front-end e il backend; infine, \textit{TM.Client} offre l'interfaccia utente, consentendo l'interazione con le funzionalità del sistema.
\\
L'analisi dei namespace, delle classi principali e delle dipendenze interne ed esterne ha permesso di comprendere non solo il ruolo di ciascun progetto, ma anche le interazioni e le relazioni tra essi, che costituiscono una rete coerente e scalabile. Tale organizzazione favorisce la manutenibilità, l'estendibilità e la qualità del codice, elementi fondamentali per sistemi complessi come quelli destinati alla gestione di ticket, workflow e processi aziendali.
\\
In sintesi, la soluzione \textit{TicketManagement} rappresenta un esempio di architettura modulare e stratificata, in cui ogni progetto contribuisce a un ecosistema integrato, garantendo uniformità dei dati, orchestrazione delle operazioni, separazione dei compiti e scalabilità complessiva del sistema. Questa struttura architetturale costituirà la base per l'analisi delle funzionalità e dei pattern implementati nei capitoli successivi.

